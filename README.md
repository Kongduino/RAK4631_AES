# RAK4631_AES

This is a demo for my extension to the [Adafruit_nRFCrypto](https://github.com/Kongduino/Adafruit_nRFCrypto), which adds AES encryption. It adds a class, nRFCrypto_AES:

```c
class nRFCrypto_AES {
  public:
    nRFCrypto_AES(void);
    bool begin(void);
    void end(void);
    int Process(char *msg, uint8_t msgLen, uint8_t *IV, uint8_t *pKey, uint8_t pKeyLen,
                   char *retBuf, SaSiAesEncryptMode_t modeFlag, SaSiAesOperationMode_t opMode);
    SaSiAesEncryptMode_t encryptFlag = (SaSiAesEncryptMode_t) 0; // SASI_AES_ENCRYPT
    SaSiAesEncryptMode_t decryptFlag = (SaSiAesEncryptMode_t) 1; // SASI_AES_DECRYPT
    SaSiAesOperationMode_t ecbMode = (SaSiAesOperationMode_t) 0; // SASI_AES_MODE_ECB
    SaSiAesOperationMode_t cbcMode = (SaSiAesOperationMode_t) 1; // SASI_AES_MODE_CBC
    SaSiAesOperationMode_t ctrMode = (SaSiAesOperationMode_t) 3; // SASI_AES_MODE_CTR
  private:
    bool _begun;
    SaSiAesPaddingType_t _paddingType = (SaSiAesPaddingType_t) 0; // SASI_AES_PADDING_NONE
    SaSiAesKeyType_t _userKey = (SaSiAesKeyType_t) 0; // SASI_AES_USER_KEY
};
```

The `Process` function does everything for you: ECB/CBC/CTR, and encrypt/decrypt.

## Installation

Remove (and possibly save somewhere) the original version of the Adafruit library, and install mine. Since the only thing it does is **add** things, without removing anything, it is safe to use as a replacement. After that you use the usual `#include "Adafruit_nRFCrypto.h"` statement, and create an `nRFCrypto_AES` object. The sample code here shows how to do all 6 operations. The IV and encryption key are generated by the `nRFCrypto.Random` class.

```c
void testAES() {
  Serial.println("AES test");
  nRFCrypto.begin();
  nRFCrypto_AES aes;
  if (!aes.begin()) {
    Serial.println("Could not start AES!");
    return;
  }
  Serial.println("======================");
  Serial.println(" * Random");
  Serial.println("======================");
  uint8_t myIV[16];
  nRFCrypto.Random.generate(myIV, 16);
  Serial.println("myIV:");
  hexDump((char*)myIV, 16);
  uint8_t pKey[16];
  nRFCrypto.Random.generate(pKey, 16);
  Serial.println("pKey:");
  hexDump((char*)pKey, 16);
  char pDataIn[65] = "Ca va chez vous les enfants...? Sinon il faut me le dire, hein ?";
  char smallData[24] = {
    0xb8, 0x4d, 0x39, 0x1a, 0x03, 0x3a, 0x0f, 0xed, 0x82, 0x97, 0x0d, 0x05,
    0xb8, 0x4d, 0x39, 0x1a, 0x03, 0x3a, 0x0f, 0xed, 0x82, 0x97, 0x0d, 0x05
  };
  char pDataOut[65] = {0};
  char pDataRe[65] = {0};
  size_t dataOutBuffSize;
  Serial.println("AES test");
  Serial.println("======================");
  Serial.println(" * ECB");
  Serial.println("======================");
  int err = aes.Process(pDataIn, 64, myIV, pKey, 16, pDataOut, aes.encryptFlag, aes.ecbMode);
  // myIV is not needed since it's ECB, but we need the parameter.
  // Could pass just about anything
  if (err < 0) {
    Serial.println("Error " + String(err));
  } else {
    hexDump(pDataOut, 64);
  }
  err = aes.Process(pDataOut, 64, myIV, pKey, 16, pDataRe, aes.decryptFlag, aes.ecbMode);
  if (err < 0) {
    Serial.println("Error " + String(err));
  } else {
    hexDump(pDataRe, 64);
  }

  Serial.println(" * Small Blocks");
  Serial.println("----------------------");
  memset(pDataOut, 0, 65);
  memset(pDataRe, 0, 65);
  hexDump(smallData, 12);
  err = aes.Process(smallData, 12, myIV, pKey, 16, pDataOut, aes.encryptFlag, aes.ecbMode);
  // myIV is not needed since it's ECB, but we need the parameter.
  // Could pass just about anything
  if (err < 0) {
    Serial.println("Error " + String(err));
  } else {
    hexDump(pDataOut, 16);
  }
  err = aes.Process(pDataOut, 16, myIV, pKey, 16, pDataRe, aes.decryptFlag, aes.ecbMode);
  if (err < 0) {
    Serial.println("Error " + String(err));
  } else {
    hexDump(pDataRe, 12);
  }

  Serial.println("======================");
  Serial.println(" * CBC");
  Serial.println("======================");
  memset(pDataOut, 0, 65);
  memset(pDataRe, 0, 65);
  err = aes.Process(pDataIn, 64, myIV, pKey, 16, pDataOut, aes.encryptFlag, aes.cbcMode);
  if (err < 0) {
    Serial.println("Error " + String(err));
  } else {
    hexDump(pDataOut, 64);
  }
  err = aes.Process(pDataOut, 64, myIV, pKey, 16, pDataRe, aes.decryptFlag, aes.cbcMode);
  if (err < 0) {
    Serial.println("Error " + String(err));
  } else {
    hexDump(pDataRe, 64);
  }

  Serial.println(" * Small Blocks");
  Serial.println("----------------------");
  memset(pDataOut, 0, 65);
  memset(pDataRe, 0, 65);
  hexDump(pDataIn, 12);
  err = aes.Process(pDataIn, 12, myIV, pKey, 16, pDataOut, aes.encryptFlag, aes.cbcMode);
  if (err < 0) {
    Serial.println("Error " + String(err));
  } else {
    hexDump(pDataOut, 16);
  }
  err = aes.Process(pDataOut, 16, myIV, pKey, 16, pDataRe, aes.decryptFlag, aes.cbcMode);
  if (err < 0) {
    Serial.println("Error " + String(err));
  } else {
    hexDump(pDataRe, 12);
  }

  Serial.println("======================");
  Serial.println(" * CTR");
  Serial.println("======================");
  memset(pDataOut, 0, 65);
  memset(pDataRe, 0, 65);
  err = aes.Process(pDataIn, 64, myIV, pKey, 16, pDataOut, aes.encryptFlag, aes.ctrMode);
  if (err < 0) {
    Serial.println("Error " + String(err));
  } else {
    hexDump(pDataOut, 64);
  }
  err = aes.Process(pDataOut, 64, myIV, pKey, 16, pDataRe, aes.decryptFlag, aes.ctrMode);
  if (err < 0) {
    Serial.println("Error " + String(err));
  } else {
    hexDump(pDataRe, 64);
  }

  Serial.println(" * Small Blocks");
  Serial.println("----------------------");
  memset(pDataOut, 0, 65);
  memset(pDataRe, 0, 65);
  hexDump(pDataIn, 17);
  err = aes.Process(pDataIn, 17, myIV, pKey, 16, pDataOut, aes.encryptFlag, aes.ctrMode);
  if (err < 0) {
    Serial.println("Error " + String(err));
  } else {
    hexDump(pDataOut, 32);
  }
  err = aes.Process(pDataOut, 64, myIV, pKey, 16, pDataRe, aes.decryptFlag, aes.ctrMode);
  if (err < 0) {
    Serial.println("Error " + String(err));
  } else {
    hexDump(pDataRe, 17);
  }
  nRFCrypto.end();
}
```
